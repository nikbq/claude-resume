"""
Utility functions for Claude Resume
"""
import os
import re
from pathlib import Path

def clean_message_content(content):
    """Clean message content by removing caveat text and getting first sensible content"""
    if not content:
        return ''
    
    # Convert content to string if it's not already
    if isinstance(content, list):
        if content and isinstance(content[0], dict):
            content = content[0].get('text', '')
        elif content:
            content = str(content[0])
        else:
            return ''
    
    # Skip command messages (like /clear) and local command output
    if ('<command-name>' in content and '<command-message>' in content) or '<local-command-stdout>' in content:
        return ''
    
    # Remove common caveat patterns
    caveat_patterns = [
        r"Caveat:.*?DO NOT respond.*?asks you to\.",
        r"The messages below were generated.*?explicitly asks you to\.",
        r"DO NOT respond to these messages.*?asks you to\.",
        r"Note:.*?were generated by.*?local commands\.",
        r"^\s*Caveat:.*?\n\n",
        r"<command-name>.*?</command-name>.*?<command-message>.*?</command-message>.*?<command-args>.*?</command-args>",
    ]
    
    for pattern in caveat_patterns:
        content = re.sub(pattern, '', content, flags=re.DOTALL | re.IGNORECASE)
    
    # Get first sensible line/paragraph
    lines = content.strip().split('\n')
    sensible_lines = []
    
    for line in lines:
        line = line.strip()
        if line and not line.lower().startswith(('caveat:', 'note:', 'warning:')):
            sensible_lines.append(line)
            # Take first 2 lines or up to 200 chars
            if len(sensible_lines) >= 2 or len(' '.join(sensible_lines)) > 200:
                break
    
    result = ' '.join(sensible_lines)
    
    # Truncate if too long
    if len(result) > 250:
        result = result[:247] + '...'
    
    return result

def get_project_from_path(cwd):
    """Extract project name from working directory path"""
    if not cwd or cwd == 'Unknown':
        return None
    
    path = Path(cwd)
    # Get the last meaningful directory name
    if path.name and path.name not in ('.', '~', 'Users'):
        return path.name
    elif path.parent.name and path.parent.name not in ('.', '~', 'Users'):
        return path.parent.name
    
    return None

def should_show_chat(chat, current_dir):
    """Determine if a chat should be shown based on current directory context"""
    if not current_dir:
        return True  # Show all if no context
    
    current_path = Path(current_dir).resolve()
    
    # If running from home directory, show all
    if current_path == Path.home():
        return True
    
    # For non-home directories, be strict - only show exact matches
    chat_cwd = chat.get('cwd', '')
    if chat_cwd and chat_cwd != 'Unknown':
        try:
            chat_path = Path(chat_cwd).resolve()
            # Only show if chat is from current directory or its subdirectories
            if current_path == chat_path or current_path in chat_path.parents:
                return True
        except:
            pass
    
    return False

def filter_messages(messages):
    """Filter out empty or non-meaningful messages"""
    filtered = []
    
    for msg in messages:
        if not msg.get('message'):
            continue
            
        message_data = msg['message']
        role = message_data.get('role', '')
        content = message_data.get('content', '')
        
        # Skip empty messages for both assistant and user
        if not content or (isinstance(content, str) and not content.strip()):
            continue
        if isinstance(content, list) and not any(c.get('text', '').strip() if isinstance(c, dict) else str(c).strip() for c in content):
            continue
        
        filtered.append(msg)
    
    return filtered

def extract_summary(messages):
    """Extract summary from chat messages if available"""
    # First check for dedicated summary objects (new format)
    for msg in messages:
        if msg.get('type') == 'summary' and msg.get('summary'):
            summary = msg['summary'].strip()
            # Clean and truncate
            summary = ' '.join(summary.split())[:200]
            return summary
    
    # Fallback to looking in message content (old format)
    for msg in messages:
        if not msg.get('message'):
            continue
        
        content = msg['message'].get('content', '')
        if not content:
            continue
            
        # Convert content to string
        if isinstance(content, list):
            if content and isinstance(content[0], dict):
                content = content[0].get('text', '')
            elif content:
                content = str(content[0])
            else:
                continue
        
        # Look for summary patterns in content
        summary_patterns = [
            r'<summary>(.*?)</summary>',
            r'Summary:(.*?)(?:\n\n|$)',
            r'SUMMARY:(.*?)(?:\n\n|$)',
            r'## Summary\n(.*?)(?:\n\n|$)',
        ]
        
        for pattern in summary_patterns:
            match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
            if match:
                summary = match.group(1).strip()
                # Clean and truncate
                summary = ' '.join(summary.split())[:200]
                return summary
    
    return None